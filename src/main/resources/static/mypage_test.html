<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>마이페이지 API 테스트</title>
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background-color: #f4f7f6; color: #333; }
    .container { max-width: 800px; margin: 0 auto; background-color: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
    h1, h2 { color: #007bff; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; margin-top: 30px; }
    .section { margin-bottom: 40px; padding: 20px; border: 1px solid #e0e0e0; border-radius: 6px; background-color: #fafafa; }
    label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
    input[type="text"], input[type="password"], input[type="email"] {
        width: calc(100% - 20px); padding: 10px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 4px; font-size: 1rem;
    }
    button {
        padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; font-weight: bold;
        background-color: #28a745; color: white; transition: background-color 0.2s; margin-right: 10px;
    }
    button:hover { background-color: #218838; }
    button.danger { background-color: #dc3545; }
    button.danger:hover { background-color: #c82333; }
    button.secondary { background-color: #6c757d; }
    button.secondary:hover { background-color: #5a6268; }
    .result-box {
        background-color: #e9ecef; padding: 15px; border-radius: 4px; margin-top: 20px;
        font-family: 'Consolas', 'Courier New', monospace; white-space: pre-wrap; word-wrap: break-word;
        border: 1px solid #ced4da;
    }
    .error { color: #dc3545; font-weight: bold; }
    .success { color: #28a745; font-weight: bold; }
    p.message { margin-top: 10px; font-size: 0.95rem; }
  </style>
</head>
<body>
<div class="container">
  <h1>마이페이지 API 테스트</h1>
  <p>※ 이 페이지는 스프링부트 서버에서 직접 서빙되며, 백엔드 API 테스트를 위한 임시 프론트엔드입니다.</p>
  <p><strong>백엔드 서버 포트 (스프링 부트): 8080 (설정에 따라 변경될 수 있음)</strong></p>

  <!-- 공통 설정: 로그인 ID (테스트용) -->
  <div class="section">
    <h2>테스트 설정</h2>
    <label for="testLoginId">테스트할 로그인 ID:</label>
    <input type="text" id="testLoginId" value="testuser" placeholder="로그인된 사용자 ID">
    <p>※ 이 ID는 'X-Test-Login-Id' 헤더로 전송됩니다. MyPageController에서 `@RequestHeader`로 이 값을 읽어 사용해야 합니다.</p>
  </div>

  <!-- 내 정보 조회 -->
  <div class="section">
    <h2>1. 내 정보 조회</h2>
    <button onclick="getUserInfo()">내 정보 조회</button>
    <div id="userInfoResult" class="result-box"></div>
  </div>

  <!-- 최종 정보 수정 (한번에) -->
  <div class="section">
    <h2>2. 최종 정보 수정 (한번에 처리)</h2>
    <p>※ 닉네임, 비밀번호, 이메일 변경을 한 번에 요청합니다.</p>
    <h3>닉네임 변경</h3>
    <label for="newNicknameInput">새 닉네임:</label>
    <input type="text" id="newNicknameInput" placeholder="새로운 닉네임">
    <button class="secondary" onclick="checkNicknameAvailability()">닉네임 중복 확인</button>
    <p id="nicknameAvailabilityMsg" class="message"></p>

    <h3>비밀번호 변경</h3>
    <label for="currentPasswordInput">현재 비밀번호:</label>
    <input type="password" id="currentPasswordInput" placeholder="현재 비밀번호">
    <label for="newPasswordInput">새 비밀번호:</label>
    <input type="password" id="newPasswordInput" placeholder="새 비밀번호">
    <label for="newPasswordConfirmInput">새 비밀번호 확인:</label>
    <input type="password" id="newPasswordConfirmInput" placeholder="새 비밀번호 확인">
    <button class="secondary" onclick="validatePasswordChange()">비밀번호 유효성 검사</button>
    <p id="passwordValidationMsg" class="message"></p>

    <h3>이메일 변경</h3>
    <label for="newEmailInput">새 이메일:</label>
    <input type="email" id="newEmailInput" placeholder="새로운 이메일">
    <button class="secondary" onclick="requestEmailVerification()">이메일 인증코드 요청</button>
    <p id="emailRequestMsg" class="message"></p>

    <label for="emailVerificationCodeInput">이메일 인증코드:</label>
    <input type="text" id="emailVerificationCodeInput" placeholder="이메일로 받은 인증코드">
    <button class="secondary" onclick="verifyEmailCode()">인증코드 확인</button>
    <p id="emailVerificationMsg" class="message"></p>

    <hr style="margin: 30px 0;">
    <button onclick="updateMyPage()" style="background-color: #007bff;">정보 수정 완료</button>
    <div id="updateResult" class="result-box"></div>
  </div>

  <!-- 최근 게시글 조회 (별도 엔드포인트) -->
  <div class="section">
    <h2>3. 최근 게시글 조회</h2>
    <button onclick="getRecentViews()">최근 본 게시글 조회</button>
    <div id="recentViewsResult" class="result-box"></div>
    <p>※ `/api/posts/detail/{id}` 로 접속 시, 해당 게시글 ID는 자동으로 최근 본 게시글 목록에 추가됩니다. 먼저 게시글을 몇 개 생성하고, 상세 조회 API로 들어가보세요.</p>
    <p>게시글 ID는 'PostController'의 글 전체 조회 API (`/api/posts`)를 통해 확인하거나, 직접 생성한 게시글 ID를 입력하세요.</p>
    <label for="simulatedPostId">시뮬레이션할 게시글 ID (옵션):</label>
    <input type="text" id="simulatedPostId" placeholder="예: 1, 2, 3">
    <button onclick="simulatePostView()">게시글 조회 시뮬레이션</button>
    <p id="simulateMsg" class="message"></p>
  </div>

</div>

<script>
  // 백엔드 API의 기본 URL (HTML과 같은 서버에서 서빙되므로 상대 경로로 설정)
  const BASE_URL = '/api';
  const MYPAGE_URL = `${BASE_URL}/mypage`;
  const RECENT_VIEWS_URL = `${MYPAGE_URL}/recent-views`; // MYPAGE_URL의 서브 경로로 변경됨
  const POSTS_URL = `${BASE_URL}/posts`; // 게시판 API URL

  // 모든 API 요청 시 사용자 ID를 헤더에 포함하기 위함
  function getCommonHeaders() {
      const loginId = document.getElementById('testLoginId').value;
      return {
          'Content-Type': 'application/json',
          'X-Test-Login-Id': loginId
      };
  }

  // --- 유틸리티 함수 ---
  async function fetchData(url, options = {}) {
      try {
          const customHeaders = new Headers(getCommonHeaders());
          if (options.headers) {
              for (const key in options.headers) {
                  customHeaders.set(key, options.headers[key]);
              }
          }
          options.headers = customHeaders;

          const response = await fetch(url, options);

          if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`HTTP Error! Status: ${response.status}, Message: ${errorText}`);
          }

          const contentType = response.headers.get('content-type');
          if (contentType && contentType.includes('application/json')) {
              return await response.json();
          } else {
              return await response.text();
          }
      } catch (error) {
          console.error('API Error:', error);
          throw error;
      }
  }

  // --- API 호출 함수들 ---

  // 1. 내 정보 조회
  async function getUserInfo() {
      const resultBox = document.getElementById('userInfoResult');
      resultBox.innerHTML = '조회 중...';
      try {
          const data = await fetchData(`${MYPAGE_URL}/info`);
          resultBox.className = 'result-box success';
          resultBox.innerHTML = `<pre>${JSON.stringify(data, null, 2)}</pre>`;
      } catch (error) {
          resultBox.className = 'result-box error';
          resultBox.innerHTML = `오류: ${error.message}`;
      }
  }

  // 2. 최종 정보 수정 섹션의 예비 검증 함수들
  async function checkNicknameAvailability() {
      const newNickname = document.getElementById('newNicknameInput').value;
      const msgElem = document.getElementById('nicknameAvailabilityMsg');
      if (!newNickname) {
          msgElem.className = 'message error';
          msgElem.textContent = '닉네임을 입력해주세요.';
          return;
      }
      try {
          const data = await fetchData(`${MYPAGE_URL}/nickname/check-availability?nickname=${newNickname}`);
          msgElem.className = 'message success';
          msgElem.textContent = data;
      } catch (error) {
          msgElem.className = 'message error';
          msgElem.textContent = `오류: ${error.message.split(', Message: ')[1] || error.message}`;
      }
  }

  async function validatePasswordChange() {
      const currentPassword = document.getElementById('currentPasswordInput').value;
      const newPassword = document.getElementById('newPasswordInput').value;
      const newPasswordConfirm = document.getElementById('newPasswordConfirmInput').value;
      const msgElem = document.getElementById('passwordValidationMsg');

      if (!currentPassword || !newPassword || !newPasswordConfirm) {
          msgElem.className = 'message error';
          msgElem.textContent = '모든 비밀번호 필드를 입력해주세요.';
          return;
      }

      try {
          const data = await fetchData(`${MYPAGE_URL}/password/validate`, {
              method: 'POST',
              body: JSON.stringify({ currentPassword, newPassword, newPasswordConfirm })
          });
          msgElem.className = 'message success';
          msgElem.textContent = data;
      } catch (error) {
          msgElem.className = 'message error';
          msgElem.textContent = `오류: ${error.message.split(', Message: ')[1] || error.message}`;
      }
  }

  async function requestEmailVerification() {
      const newEmail = document.getElementById('newEmailInput').value;
      const msgElem = document.getElementById('emailRequestMsg');

      if (!newEmail) {
          msgElem.className = 'message error';
          msgElem.textContent = '새 이메일을 입력해주세요.';
          return;
      }

      try {
          const data = await fetchData(`${MYPAGE_URL}/email/request-verification`, {
              method: 'POST',
              body: JSON.stringify({ newEmail })
          });
          msgElem.className = 'message success';
          msgElem.textContent = data;
      } catch (error) {
          msgElem.className = 'message error';
          msgElem.textContent = `오류: ${error.message.split(', Message: ')[1] || error.message}`;
      }
  }

  async function verifyEmailCode() {
      const code = document.getElementById('emailVerificationCodeInput').value;
      const msgElem = document.getElementById('emailVerificationMsg');

      if (!code) {
          msgElem.className = 'message error';
          msgElem.textContent = '인증코드를 입력해주세요.';
          return;
      }

      try {
          const data = await fetchData(`${MYPAGE_URL}/email/verify-code`, {
              method: 'POST',
              body: JSON.stringify({ code })
          });
          msgElem.className = 'message success';
          msgElem.textContent = data;
      } catch (error) {
          msgElem.className = 'message error';
          msgElem.textContent = `오류: ${error.message.split(', Message: ')[1] || error.message}`;
      }
  }

  // 2. 최종 정보 수정 (수정 완료 버튼)
  async function updateMyPage() {
      const resultBox = document.getElementById('updateResult');
      resultBox.innerHTML = '수정 요청 중...';

      const requestBody = {};
      const newNickname = document.getElementById('newNicknameInput').value;
      const currentPassword = document.getElementById('currentPasswordInput').value;
      const newPassword = document.getElementById('newPasswordInput').value;
      const newPasswordConfirm = document.getElementById('newPasswordConfirmInput').value;
      const newEmail = document.getElementById('newEmailInput').value;
      const emailVerificationCode = document.getElementById('emailVerificationCodeInput').value;

      if (newNickname) requestBody.newNickname = newNickname;
      if (currentPassword) requestBody.currentPassword = currentPassword;
      if (newPassword) requestBody.newPassword = newPassword;
      if (newPasswordConfirm) requestBody.newPasswordConfirm = newPasswordConfirm;
      if (newEmail) requestBody.newEmail = newEmail;
      if (emailVerificationCode) requestBody.emailVerificationCode = emailVerificationCode;

      if (Object.keys(requestBody).length === 0) {
          resultBox.className = 'result-box error';
          resultBox.innerHTML = '변경할 내용을 입력해주세요.';
          return;
      }

      try {
          const data = await fetchData(`${MYPAGE_URL}`, {
              method: 'PATCH',
              body: JSON.stringify(requestBody)
          });
          resultBox.className = 'result-box success';
          resultBox.innerHTML = `성공: ${data}`;
      } catch (error) {
          resultBox.className = 'result-box error';
          resultBox.innerHTML = `오류: ${error.message.split(', Message: ')[1] || error.message}`;
      }
  }

  // 3. 최근 본 게시글 조회
  async function getRecentViews() {
      const resultBox = document.getElementById('recentViewsResult');
      resultBox.innerHTML = '조회 중...';
      try {
          // MYPAGE_URL에 recent-views가 붙도록 변경됨
          const data = await fetchData(`${RECENT_VIEWS_URL}`);
          resultBox.className = 'result-box success';
          resultBox.innerHTML = `<pre>${JSON.stringify(data, null, 2)}</pre>`;
      } catch (error) {
          resultBox.className = 'result-box error';
          resultBox.innerHTML = `오류: ${error.message}`;
      }
  }

  // 게시글 상세 조회 시뮬레이션 (최근 본 게시글 추가 로직 트리거)
  async function simulatePostView() {
      const postId = document.getElementById('simulatedPostId').value;
      const msgElem = document.getElementById('simulateMsg');

      if (!postId) {
          msgElem.className = 'message error';
          msgElem.textContent = '게시글 ID를 입력해주세요.';
          return;
      }

      try {
          // PostController의 글 상세 조회 API를 호출
          const data = await fetchData(`${POSTS_URL}/detail/${postId}`);
          msgElem.className = 'message success';
          msgElem.textContent = `게시글 ID: ${postId} 상세 조회 성공. (이 호출로 최근 본 게시글에 추가됨)\n게시글 제목: ${data.title}`;
      } catch (error) {
          msgElem.className = 'message error';
          msgElem.textContent = `오류: ${error.message.split(', Message: ')[1] || error.message}`;
      }
  }

</script>
</body>
</html>